<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Will Acton : Web Developer and Brazilian Jiu Jitsu Fanatic</title><link href="http://willacton.com/" rel="alternate"></link><link href="http://willacton.com/feeds/will-acton.atom.xml" rel="self"></link><id>http://willacton.com/</id><updated>2014-07-17T00:00:00-07:00</updated><entry><title>Mobile Geolocation Gotchas</title><link href="http://willacton.com/geolocation-gotchas.html" rel="alternate"></link><updated>2014-07-17T00:00:00-07:00</updated><author><name>Will Acton</name></author><id>tag:willacton.com,2014-07-17:geolocation-gotchas.html</id><summary type="html">&lt;p&gt;One of the cooler features I wanted to develop when I started planning my current main project, &lt;a href="http://github.com/Lokeh/BusTracker"&gt;PDX InTransit&lt;/a&gt;, was the ability to filter through stops based on their proximity to your current location. Once I started getting into the details of HTML5's geolocation, it seemed fairly easy: grab the client's position, plug it into Google Maps' API and then using the interface I already had developed for Trimet's services, pull in the stops within, say, 500m. This worked perfect on my desktop and when testing with Chrome's mobile emulation.&lt;/p&gt;
&lt;p&gt;However, once I started playing with it on my phone, I found that it was horribly inaccurate at finding my location. Pulling out some of the data it was returning, it was show a range of almost 1200m that my position could fall within. This seemed silly: when I opened up Goole's Maps app or any other app using geolocation, it worked fine. Even websites seemed to find my location fine, although somtimes it would take a minute...&lt;/p&gt;
&lt;p&gt;It turns out that on mobile (I haven't been able to figure out yet if it's Android, mobile Chrome, or something in between which causes this), even with enableHighAccuracy set to true, tries to return a position as quickly as possible (at the cost of accuracy). However, if instead of using 'getCurrentPosition' - which is a one-time call to the geolocation API - one uses 'watchPosition,' which constantly reports the clients position, after a few cycles it will slowly narrow it down to an acceptable range. Here's the code I ended up using:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;$scope&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getLocation&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;callback&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;watch&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;navigator&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;geolocation&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;watchPosition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;callback&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;$scope&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;geoError&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nx"&gt;enableHighAccuracy&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;timeout&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3000&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;maximumAge&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;init&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;$scope&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getLocation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;loc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;loc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;coords&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;accuracy&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;150&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;navigator&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;geolocation&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;clearWatch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;watch&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="nx"&gt;$scope&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;loc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;lat&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;loc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;coords&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;latitude&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;lng&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;loc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;coords&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;longitude&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
            &lt;span class="nx"&gt;$scope&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;drawMap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="nx"&gt;$scope&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getNearbyStops&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;loc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;coords&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;latitude&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;loc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;coords&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;longitude&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="p"&gt;});&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The problem with this solution is that there's about a 2-6 second lag time in which it has to narrow down your location. My goal is to explore other options to get more accurate information, quicker. For now showing a swirly ball while it finds the user will have to suffice.&lt;/p&gt;</summary><category term="JavaScript"></category><category term="AngularJS"></category><category term="geolocation"></category><category term="google maps"></category></entry><entry><title>Fairy Magic: Exploring Angular-like 2-Way Databinding</title><link href="http://willacton.com/fairy-magic.html" rel="alternate"></link><updated>2014-07-03T00:00:00-07:00</updated><author><name>Will Acton</name></author><id>tag:willacton.com,2014-07-03:fairy-magic.html</id><summary type="html">&lt;p&gt;I like AngularJS. A lot. I've explored Backbone on a very surface level, but Angular does a lot of really nice things out of the box that I've been able to take great advantage of in my &lt;a href="http://github.com/Lokeh/Bustracker"&gt;current main project&lt;/a&gt;, PDX InTransit - a mobile app written to quickly and easily find stops and arrivals for Portland's Trimet system.&lt;/p&gt;
&lt;p&gt;Probably the most eye-candyish aspect of Angular (and many of the other modern MV*-esque frontend frameworks) is two-way databinding. It does a number of very neat things, notably:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Greatly simplifies your code, and allows you to better separate your concerns; your controller code doesn't need to muddle with your view code at all.&lt;/li&gt;
&lt;li&gt;Allows you to easily make your UI feel very responsive, creating a snappy, 'live'-feeling experience to your clients that automatically updates based on the user's actions. Basically, what any good front end developer strives to do.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;An easy example is displaying a variable in a label or span and updating it via text input. 'Normally,' this would require diving into 'selector-hell' - using either jQuery or the native selector functions to find the appropriate span node in the DOM, update it, check the input node, update it again... this is a lot of code that ends up being tied directly to the markup on my page. Not very reusable, and everytime my variable changes I have to make sure to update both the label and the text input, polluting my controller code with view stuff. With two-way databinding (in this case, using Angular), I can simply do this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;span&amp;gt;&lt;/span&gt;{{ input }}&lt;span class="nt"&gt;&amp;lt;/span&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;input&lt;/span&gt; &lt;span class="na"&gt;ng-model=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;input&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;That's it. No more code required for the view. No messing with the DOM. In my controller code, I might be using the input to search a database or flat file, or maybe once the user is happy with their content and how it's displaying I'll post it to a CMS of some sort. I don't have to do anything to make sure that my input variable is updating from the view - two-way databinding takes care of that for me.&lt;/p&gt;
&lt;p&gt;Magic, I say! And many have made that complaint about Angular and many of the other JavaScript frameworks: that people new(er) to JavaScript and learning Angular will succumb to it's spell and let it do all the heavy lifting, leaving the young developer unable to understand or troubleshoot anything!&lt;/p&gt;
&lt;p&gt;So I decided to try to do it myself: enter &lt;a href="http://github.com/Lokeh/PixieDust"&gt;PixieDust&lt;/a&gt;, a two-way databinding library I wrote over the course of a couple days. At the moment, it is incredibly simple: you can wire up variables in the view, and detect text input and button clicks. It was an interesting endeavor, and was great practice in coming up with ways to transform the DOM and use data structures to keep track of constantly changing data.&lt;/p&gt;
&lt;p&gt;One of the shortfalls of my current solution is that it is constantly checking the bound variables every 60ms (to account for visual lag) - which could get hairy with large amounts of variables bound in the view. The first iteration, though, I was constantly traversing the DOM every cycle! Yikes! AngularJS solves this problem by wrapping all of it's assignments in it's $apply method, which notifies the binding to update.&lt;/p&gt;
&lt;p&gt;Another interesting problem someone on reddit pointed out is that addEventListener does not garbage collect when the DOM node is destroyed. While not too big of a deal for small apps, an app with a large amount of views or a few views with LOTS of forms. Apparently, switching to binding directly to the node property is the way to go, but something I want to investigate more before I implement.&lt;/p&gt;
&lt;p&gt;I dived into the source code of Angular and used that as a sort-of kind-of model, but for the most part I tried to just work through each hurdle I came across and see what I came up with at the end. Overall, it was a fun experiment that gave me an opportunity to peel back a bit of how AngularJS works. I'll probably revisit it later to see what I would do differently, as well as add more functionality to it - it might be useful in a future project!&lt;/p&gt;</summary><category term="JavaScript"></category><category term="AngularJS"></category><category term="exploring"></category></entry><entry><title>Refactor, Refactor, Refactor: Learns from JavaScript, Pragmatic Programmer</title><link href="http://willacton.com/learns-from-javascript-pragmatic-programmer.html" rel="alternate"></link><updated>2014-06-13T19:00:00-07:00</updated><author><name>Will Acton</name></author><id>tag:willacton.com,2014-06-13:learns-from-javascript-pragmatic-programmer.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;Most people assume that maintenace begins when an application is released, that maintenance means fixing bugs and enhancing features. We think these people are wrong. Programmers are constantly in maintenance mode. Our understanding changes day by day. New requirements arrive as we're designing or coding. perhaps the environment changes. Whatever the reason, maintenance is not a discrete activity, but a routine part of the entire development process.
            - &lt;em&gt;The Pragmatic Programmer&lt;/em&gt;, pg. 26&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A little over a month ago, I decided to learn JavaScript. This wouldn't be my first time learning a new language: over the years I've dealt in C and C++, Perl, PHP, Python, BASIC... never JavaScript. I had tried to avoid it for all I could, what with people feeding me horror stories of poor performance, inconsistant cross-browser compatability, and terrible coding standards baked into the language. And many of the stories they told me are true, but the war in the early 2000s was won and the victor clear: JavaScript is here to stay. Also, having spent the bulk of my time coding using PHP, according to popular opinion I've already stared into the abyss too long.&lt;/p&gt;
&lt;p&gt;However, I am armed with new information, and a new way of thinking about software and it's development. I am fairly confident in my ability to write code - as in, it compiles/runs, it doesn't throw any (serious) exceptions, and does it's function. Pumping out a program that does mostly what I want isn't something I worry about anymore. I know that most problems I can think of or come across, someone, somewhere has solved it at this point; the important part is the &lt;strong&gt;implementation&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;I am currently working on a mobile application to track routes, stops and arrivals for the Portland Trimet system. I have probably rewritten each piece of the app at least once, and near the top of my to do list is "Refactor factories into one 'transitFactory' that divides controller from model better." I have accepted the fact that, at least on my personal projects, rewriting large amounts of code is not only going to happen but is absolutely a good thing. As I rewrite, I will learn how I can plan things better for my next project, as well as understand how to create code that can be rewritten - another thing &lt;em&gt;The Pragmatic Programmer&lt;/em&gt;, by Andrew Hunt and David Thomas, talks about.&lt;/p&gt;
&lt;p&gt;And that's what I think about now when I sit down to code. Not how I'm going to make my code run, but how I'm going to structure the code so that it's easily maintenable, easily reused, and easily read. I want to stop hating me-from-3-months ago, and to do that I'm going to do me-in-3-months a solid by planning, and then refactoring, refactoring, refactoring.&lt;/p&gt;</summary><category term="JavaScript"></category><category term="Learns"></category><category term="Pragmatic Programmer"></category></entry></feed>